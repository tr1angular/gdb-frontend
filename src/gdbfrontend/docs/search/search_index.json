{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GDBFrontend README GDBFrontend is an easy, flexible and extensionable gui debugger. Installing Requirements GDB => 8.2 (with python3) python3 => 3.2 tmux PIP Package (Python Wheel) [Recommended] You can install GDBFrontend with pip . sudo python3 -m pip install gdbfrontend if it is already installed and you are upgrading sudo python3 -m pip install --upgrade gdbfrontend or if you want to install specific GIT snapshot: sudo python3 setup.py install and you can run gdbfrontend Running From GIT You can download latest source and run it. You can run gdb-frontend with following commands: git clone https://github.com/rohanrhu/gdb-frontend.git gdb-frontend cd gdb-frontend ./gdbfrontend and you can open it with: http://127.0.0.1:5550/terminal/ or without terminal: http://127.0.0.1:5550/ You can open GDB shell with the command: tmux a -t gdb-frontend Arch Linux (AUR) You can install Arch Linux package for Arch-based distributions. ( AUR Package ) yay -S gdb-frontend-bin and you can run it: gdbfrontend Flatpak Flatpak package is a TODO. Embedded Debugging with GDBFrontend Follow this quick tutorial for debugging embedded devices with GDBFrontend. Python C Extension Debugging with GDBFrontend Follow this quick tutorial for debugging native C Python extensions with GDBFrontend. How to develop GDBFrontend plugins? GDBFrontend has powerful and extensible APIs. Follow this quick tutorial to learn developing GDBFrontend plugins. Features Expression Evaluter GDBFrontend has an expression evaluater that you can use multiple in sametime. Pointer Visualisation Linked-List Visualization Conditional Breakpoints Right click to a breakpoint for setting its condition. Connected Expressions Expressions of all variables, members and items are connected in GDBFrontend's VariablesExplorer. Process Manager You can watch, filter or manage processes with Process Manager. Enhanced Collabration GDBFrontend has a set of some features for collabration named as \"Enhanced Collabration\". Collabration Draw Collabration draw is available when you enable Enhanced Collabration. Click to Draw or use Ctrl + Shift + X shortcut to draw and Ctrl + Shift + C to clear all drawings. Synced Source Viewing With Enhanced Collabration all debugger clients are synchronized on source viewing. Expression hover popup variable explorer Extensibility GDBFrontend is very extensible and has powerful APIs. Some examples of GDBFrontend's extensibility. ./gdbfrontend $ gdbfrontend --help GDBFrontend is a easy, flexible and extensionable gui debugger. Options: --help, -h: Shows this help message. --version, -v: Shows version. --gdb-args = \"ARGS\" , -G \"ARGS\" : Specifies GDB command line arguments. ( Optional ) --gdb-executable = PATH, -g PATH: Specifies GDB executable path ( Default is \"gdb\" command on PATH environment variable. ) --tmux-executable = PATH, -tmux PATH: Specifies Tmux executable path ( Default is \"tmux\" command on PATH environment variable. ) --terminal-id = NAME, -t NAME: Specifies tmux terminal identifier name ( Default is \"gdb-frontend\" . ) --credentials = USER:PASS, -c USER:PASS: Specifies username and password for accessing to debugger. --host = IP, -H IP: Specifies current host address that you can access via for HTTP and WS servers. --listen = IP, -l IP: Specifies listen address for HTTP and WS servers. --port = PORT, -p PORT: Specifies HTTP port. ( 0 for random port. ) --readonly, -r: Makes code editor readonly. ( Notice: This option is not related to security. ) --workdir, -w: Specifies working directory. --plugin-dir, -P: Specifies plugins directory. --dontopenuionstartup, -D: Avoids opening UI just after startup. --verbose, -V: Enables verbose output. Options --help , -h Shows help text. --version , -v Shows version. --gdb-args=\"ARGS\", -G \"ARGS\" Specifies GDB command line arguments. (Optional) --gdb-executable=PATH , -g PATH You can specify GDB executable path like gdbfrontend --gdb-executable=/path/to/gdb . (Optional) --tmux-executable=PATH , -tmux PATH You can specify Tmux executable path like gdbfrontend --tmux-executable=/path/to/tmux . (Optional) --terminal-id=PATH , -t PATH You can specify Tmux terminal id like gdbfrontend --terminal-id=terminal-name . (Default: gdb-frontend ) --credentials=USER:PASS , -c USER:PASS Specifies username and password for accessing to debugger. --host=IP , -H IP Specifies current host address that you can access via for HTTP and WS servers. --listen=IP , -l IP Specifies listen address for HTTP and WS servers. --port=PORT , -p PORT Specifies HTTP port. (0 for random port.) --readonly, -r Makes code editor readonly. (Notice: This option is not related to security.) --workdir, -w Specifies working directory. --plugin-dir, -P Specifies plugins directory. --dontopenuionstartup , -D Avoids opening UI just after startup. --verbose , -V Enables verbose output. GDB Commands GDBFrontend's GDB commands starts with gf- . gf-refresh Refreshes all browser clients. gf-theme [theme-name] Switch to desired theme. For example: gf-theme light , gf-theme red or gf-theme default for default theme. gf-list-plugins Lists all GDBFrontend plugins in the plugin directory. gf-load-plugin [plugin-name] Loads GDBFrontend plugin. gf-unload-plugin [plugin-name] Unloads GDBFrontend plugin. Shortcuts / Hotkeys Current hotkeys are listed below. Action Hotkey Context General: Open a source file Ctrl + O GDBFrontend General: New ExpressionEvaluater Ctrl + R GDBFrontend General: New ExpressionEvaluter on native window Ctrl + Shift + R GDBFrontend General: Fuzzy source finder Ctrl + P GDBFrontend Runtime: Run F5 GDBFrontend Runtime: Continue F6 GDBFrontend Runtime: Pause/Interrupt F7 GDBFrontend Runtime: Step Over F8 GDBFrontend Runtime: Step Into F9 GDBFrontend Runtime: Step Instruction F10 GDBFrontend Runtime: Stop F11 GDBFrontend Enhanced Collabration: Toggle drawing mode Ctrl + Shift + X GDBFrontend / Enhanced Collabration: Enabled Enhanced Collabration: Clear all drawings Ctrl + Shift + C GDBFrontend / Enhanced Collabration: Enabled Themes GDBFrontend has built-in themes. For switching between themes use gf-theme [THEME] command on GDB shell. (gdb) gf-theme doki (gdb) gf-theme sky (gdb) gf-theme cyberpunk (gdb) gf-theme dark (gdb) gf-theme green (gdb) gf-theme light (gdb) gf-theme red For switching back to the default theme. (gdb) gf-theme Also you may want to look to Plugin Development Tutorial . GDBFrontend Python API You can access GDBFrontend's Python API via gdbfrontend module. (gdb) python-interactive >>> dir ( gdbfrontend ) For example, you can get all client sockets like this: >>> gdbfrontend . api . globalvars . httpServer . ws_clients { 1 : < server . GDBFrontendSocket object at 0 x ...> } or you can get all plugins: >>> gdbfrontend . plugin . getAll () [ 'hello' , 'theme_light' , 'theme_red' ] Security with Sharing Sessions You can use --credentials=USER:PASS option for adding HTTP authentication to your debugger session. Browser Compatibility GDBFrontend is mainly developing with testing on Chromium-based browsers. It will work properly with other browsers especially with Firefox but if you face some problems on other browsers, you can send a bug-report . Troubleshooting Blocking GDB shell/main-thread Most of GDBFrontend functions are thread-safe and work on GDB's main-thread. So, if you run something that is blocking on the GDB shell, GDBFrontend functions have to wait it until finish. You will get this warning when a thread-safe GDBFrontend function needs to work and you are blocking GDB's main thread. ( gdb ) shell $ ... When you exit shell, blocking GDBFrontend functions will continue working. Note: Sometimes you may get this warning without running anything in GDB shell, it means something (in GDB's event-loop) is taking a long time; in this case just ignore this warning. Zombie Processes GDBFrontend sends SIGTERM to its sub-processes, your application and its sub-processes. If your application is forking new processes and setting their PGIDs, GDBFrontend may not close them. In this case you should send SIGKILL to your processes. pkill -f gdb Expression Evaluater Performance Tips If you are using ExpressionEvaluater with very long depth expanded variables/members, your scroll and evaluater window move performance may be affected bad for pointer visualization. In this situation, you can turn off signal and slot pointings for that evaluater window. GDB-Related Issues and Tips GDB may not give sources of dynamic linked object until stepping a line that calls a function from the dynamic linked object once . You can add break point a line and step it once, then you will see sources from dynamic linked object hereafter during the session. Windows In fact, gdb-frontend is able to run on Windows but there are some serious issues in the GDB's Windows version those avoid using gdb-frontend on Windows. Of course you can use gdb-frontend on WSL if you are using Windows 10. Issues about Windows-GDB GDB's main-thread is being blocked during running process. (gdb-frontend has an interrupting mechanism to fixing this but it is not enough yet.) Windows-GDB's prompt is being blocked during running process and there are some issues about interrupting the application. WSL You can use gdb-frontend on WSL (Windows Subsystem for Linux). Issues about WSL On WSL 1, Random port option is not usable on WSL becasue /proc/net/tcp interface is not working on WSL. (WSL 2 does not has this problem.) Versioning Since v0.2.0-beta, GDBFrontend switched to a new versioning strategy. Reading Versions In vX.Y.Z-STABILITY : X is major versions, changes long term with major features and enhancements. Y is main versions that include new features and enhancements. Z is bugfix releases of main versions. STABILITY is stability level of the release. ( alpha , beta , rcN , stable ) Documentation Documentation is TODO yet. API Documentation API Documentation is TODO yet. Plugin Development You can read the Plugin Development Tutorial . Theme Development Themes are developed as plugins. Discord Join to Discord community. \ud83c\udf8a Contributing You can contribute with commiting to project or developing a plugin. All commits are welcome. \u2764\ufe0f Donate Patreon Bitcoin You can donate to support the project. QR Code Bitcoin address for donations 3KBtYfaAT42uVFd6D2XFRDTAoErLz73vpL License Copyright (C) 2019, O\u011fuzhan Ero\u011flu rohanrhu2@gmail.com (https://oguzhaneroglu.com/) GNU General Public License v3 (GPL-3) You may copy, distribute and modify the software as long as you track changes/dates in source files. Any modifications to or software including (via compiler) GPL-licensed code must also be made available under the GPL along with build & install instructions.","title":"GDBFrontend README"},{"location":"#gdbfrontend-readme","text":"GDBFrontend is an easy, flexible and extensionable gui debugger.","title":"GDBFrontend README"},{"location":"#installing","text":"","title":"Installing"},{"location":"#requirements","text":"GDB => 8.2 (with python3) python3 => 3.2 tmux","title":"Requirements"},{"location":"#pip-package-python-wheel-recommended","text":"You can install GDBFrontend with pip . sudo python3 -m pip install gdbfrontend if it is already installed and you are upgrading sudo python3 -m pip install --upgrade gdbfrontend or if you want to install specific GIT snapshot: sudo python3 setup.py install and you can run gdbfrontend","title":"PIP Package (Python Wheel) [Recommended]"},{"location":"#running-from-git","text":"You can download latest source and run it. You can run gdb-frontend with following commands: git clone https://github.com/rohanrhu/gdb-frontend.git gdb-frontend cd gdb-frontend ./gdbfrontend and you can open it with: http://127.0.0.1:5550/terminal/ or without terminal: http://127.0.0.1:5550/ You can open GDB shell with the command: tmux a -t gdb-frontend","title":"Running From GIT"},{"location":"#arch-linux-aur","text":"You can install Arch Linux package for Arch-based distributions. ( AUR Package ) yay -S gdb-frontend-bin and you can run it: gdbfrontend","title":"Arch Linux (AUR)"},{"location":"#flatpak","text":"Flatpak package is a TODO.","title":"Flatpak"},{"location":"#embedded-debugging-with-gdbfrontend","text":"Follow this quick tutorial for debugging embedded devices with GDBFrontend.","title":"Embedded Debugging with GDBFrontend"},{"location":"#python-c-extension-debugging-with-gdbfrontend","text":"Follow this quick tutorial for debugging native C Python extensions with GDBFrontend.","title":"Python C Extension Debugging with GDBFrontend"},{"location":"#how-to-develop-gdbfrontend-plugins","text":"GDBFrontend has powerful and extensible APIs. Follow this quick tutorial to learn developing GDBFrontend plugins.","title":"How to develop GDBFrontend plugins?"},{"location":"#features","text":"","title":"Features"},{"location":"#expression-evaluter","text":"GDBFrontend has an expression evaluater that you can use multiple in sametime.","title":"Expression Evaluter"},{"location":"#pointer-visualisation","text":"","title":"Pointer Visualisation"},{"location":"#linked-list-visualization","text":"","title":"Linked-List Visualization"},{"location":"#conditional-breakpoints","text":"Right click to a breakpoint for setting its condition.","title":"Conditional Breakpoints"},{"location":"#connected-expressions","text":"Expressions of all variables, members and items are connected in GDBFrontend's VariablesExplorer.","title":"Connected Expressions"},{"location":"#process-manager","text":"You can watch, filter or manage processes with Process Manager.","title":"Process Manager"},{"location":"#enhanced-collabration","text":"GDBFrontend has a set of some features for collabration named as \"Enhanced Collabration\".","title":"Enhanced Collabration"},{"location":"#collabration-draw","text":"Collabration draw is available when you enable Enhanced Collabration. Click to Draw or use Ctrl + Shift + X shortcut to draw and Ctrl + Shift + C to clear all drawings.","title":"Collabration Draw"},{"location":"#synced-source-viewing","text":"With Enhanced Collabration all debugger clients are synchronized on source viewing.","title":"Synced Source Viewing"},{"location":"#expression-hover-popup-variable-explorer","text":"","title":"Expression hover popup variable explorer"},{"location":"#extensibility","text":"GDBFrontend is very extensible and has powerful APIs. Some examples of GDBFrontend's extensibility.","title":"Extensibility"},{"location":"#gdbfrontend","text":"$ gdbfrontend --help GDBFrontend is a easy, flexible and extensionable gui debugger. Options: --help, -h: Shows this help message. --version, -v: Shows version. --gdb-args = \"ARGS\" , -G \"ARGS\" : Specifies GDB command line arguments. ( Optional ) --gdb-executable = PATH, -g PATH: Specifies GDB executable path ( Default is \"gdb\" command on PATH environment variable. ) --tmux-executable = PATH, -tmux PATH: Specifies Tmux executable path ( Default is \"tmux\" command on PATH environment variable. ) --terminal-id = NAME, -t NAME: Specifies tmux terminal identifier name ( Default is \"gdb-frontend\" . ) --credentials = USER:PASS, -c USER:PASS: Specifies username and password for accessing to debugger. --host = IP, -H IP: Specifies current host address that you can access via for HTTP and WS servers. --listen = IP, -l IP: Specifies listen address for HTTP and WS servers. --port = PORT, -p PORT: Specifies HTTP port. ( 0 for random port. ) --readonly, -r: Makes code editor readonly. ( Notice: This option is not related to security. ) --workdir, -w: Specifies working directory. --plugin-dir, -P: Specifies plugins directory. --dontopenuionstartup, -D: Avoids opening UI just after startup. --verbose, -V: Enables verbose output.","title":"./gdbfrontend"},{"location":"#options","text":"","title":"Options"},{"location":"#-help-h","text":"Shows help text.","title":"--help, -h"},{"location":"#-version-v","text":"Shows version.","title":"--version, -v"},{"location":"#-gdb-argsargs-g-args","text":"Specifies GDB command line arguments. (Optional)","title":"--gdb-args=\"ARGS\", -G \"ARGS\""},{"location":"#-gdb-executablepath-g-path","text":"You can specify GDB executable path like gdbfrontend --gdb-executable=/path/to/gdb . (Optional)","title":"--gdb-executable=PATH, -g PATH"},{"location":"#-tmux-executablepath-tmux-path","text":"You can specify Tmux executable path like gdbfrontend --tmux-executable=/path/to/tmux . (Optional)","title":"--tmux-executable=PATH, -tmux PATH"},{"location":"#-terminal-idpath-t-path","text":"You can specify Tmux terminal id like gdbfrontend --terminal-id=terminal-name . (Default: gdb-frontend )","title":"--terminal-id=PATH, -t PATH"},{"location":"#-credentialsuserpass-c-userpass","text":"Specifies username and password for accessing to debugger.","title":"--credentials=USER:PASS, -c USER:PASS"},{"location":"#-hostip-h-ip","text":"Specifies current host address that you can access via for HTTP and WS servers.","title":"--host=IP, -H IP"},{"location":"#-listenip-l-ip","text":"Specifies listen address for HTTP and WS servers.","title":"--listen=IP, -l IP"},{"location":"#-portport-p-port","text":"Specifies HTTP port. (0 for random port.)","title":"--port=PORT, -p PORT"},{"location":"#-readonly-r","text":"Makes code editor readonly. (Notice: This option is not related to security.)","title":"--readonly, -r"},{"location":"#-workdir-w","text":"Specifies working directory.","title":"--workdir, -w"},{"location":"#-plugin-dir-p","text":"Specifies plugins directory.","title":"--plugin-dir, -P"},{"location":"#-dontopenuionstartup-d","text":"Avoids opening UI just after startup.","title":"--dontopenuionstartup, -D"},{"location":"#-verbose-v","text":"Enables verbose output.","title":"--verbose, -V"},{"location":"#gdb-commands","text":"GDBFrontend's GDB commands starts with gf- .","title":"GDB Commands"},{"location":"#gf-refresh","text":"Refreshes all browser clients.","title":"gf-refresh"},{"location":"#gf-theme-theme-name","text":"Switch to desired theme. For example: gf-theme light , gf-theme red or gf-theme default for default theme.","title":"gf-theme [theme-name]"},{"location":"#gf-list-plugins","text":"Lists all GDBFrontend plugins in the plugin directory.","title":"gf-list-plugins"},{"location":"#gf-load-plugin-plugin-name","text":"Loads GDBFrontend plugin.","title":"gf-load-plugin [plugin-name]"},{"location":"#gf-unload-plugin-plugin-name","text":"Unloads GDBFrontend plugin.","title":"gf-unload-plugin [plugin-name]"},{"location":"#shortcuts-hotkeys","text":"Current hotkeys are listed below. Action Hotkey Context General: Open a source file Ctrl + O GDBFrontend General: New ExpressionEvaluater Ctrl + R GDBFrontend General: New ExpressionEvaluter on native window Ctrl + Shift + R GDBFrontend General: Fuzzy source finder Ctrl + P GDBFrontend Runtime: Run F5 GDBFrontend Runtime: Continue F6 GDBFrontend Runtime: Pause/Interrupt F7 GDBFrontend Runtime: Step Over F8 GDBFrontend Runtime: Step Into F9 GDBFrontend Runtime: Step Instruction F10 GDBFrontend Runtime: Stop F11 GDBFrontend Enhanced Collabration: Toggle drawing mode Ctrl + Shift + X GDBFrontend / Enhanced Collabration: Enabled Enhanced Collabration: Clear all drawings Ctrl + Shift + C GDBFrontend / Enhanced Collabration: Enabled","title":"Shortcuts / Hotkeys"},{"location":"#themes","text":"GDBFrontend has built-in themes. For switching between themes use gf-theme [THEME] command on GDB shell. (gdb) gf-theme doki (gdb) gf-theme sky (gdb) gf-theme cyberpunk (gdb) gf-theme dark (gdb) gf-theme green (gdb) gf-theme light (gdb) gf-theme red For switching back to the default theme. (gdb) gf-theme Also you may want to look to Plugin Development Tutorial .","title":"Themes"},{"location":"#gdbfrontend-python-api","text":"You can access GDBFrontend's Python API via gdbfrontend module. (gdb) python-interactive >>> dir ( gdbfrontend ) For example, you can get all client sockets like this: >>> gdbfrontend . api . globalvars . httpServer . ws_clients { 1 : < server . GDBFrontendSocket object at 0 x ...> } or you can get all plugins: >>> gdbfrontend . plugin . getAll () [ 'hello' , 'theme_light' , 'theme_red' ]","title":"GDBFrontend Python API"},{"location":"#security-with-sharing-sessions","text":"You can use --credentials=USER:PASS option for adding HTTP authentication to your debugger session.","title":"Security with Sharing Sessions"},{"location":"#browser-compatibility","text":"GDBFrontend is mainly developing with testing on Chromium-based browsers. It will work properly with other browsers especially with Firefox but if you face some problems on other browsers, you can send a bug-report .","title":"Browser Compatibility"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"#blocking-gdb-shellmain-thread","text":"Most of GDBFrontend functions are thread-safe and work on GDB's main-thread. So, if you run something that is blocking on the GDB shell, GDBFrontend functions have to wait it until finish. You will get this warning when a thread-safe GDBFrontend function needs to work and you are blocking GDB's main thread. ( gdb ) shell $ ... When you exit shell, blocking GDBFrontend functions will continue working. Note: Sometimes you may get this warning without running anything in GDB shell, it means something (in GDB's event-loop) is taking a long time; in this case just ignore this warning.","title":"Blocking GDB shell/main-thread"},{"location":"#zombie-processes","text":"GDBFrontend sends SIGTERM to its sub-processes, your application and its sub-processes. If your application is forking new processes and setting their PGIDs, GDBFrontend may not close them. In this case you should send SIGKILL to your processes. pkill -f gdb","title":"Zombie Processes"},{"location":"#expression-evaluater-performance-tips","text":"If you are using ExpressionEvaluater with very long depth expanded variables/members, your scroll and evaluater window move performance may be affected bad for pointer visualization. In this situation, you can turn off signal and slot pointings for that evaluater window.","title":"Expression Evaluater Performance Tips"},{"location":"#gdb-related-issues-and-tips","text":"GDB may not give sources of dynamic linked object until stepping a line that calls a function from the dynamic linked object once . You can add break point a line and step it once, then you will see sources from dynamic linked object hereafter during the session.","title":"GDB-Related Issues and Tips"},{"location":"#windows","text":"In fact, gdb-frontend is able to run on Windows but there are some serious issues in the GDB's Windows version those avoid using gdb-frontend on Windows. Of course you can use gdb-frontend on WSL if you are using Windows 10.","title":"Windows"},{"location":"#issues-about-windows-gdb","text":"GDB's main-thread is being blocked during running process. (gdb-frontend has an interrupting mechanism to fixing this but it is not enough yet.) Windows-GDB's prompt is being blocked during running process and there are some issues about interrupting the application.","title":"Issues about Windows-GDB"},{"location":"#wsl","text":"You can use gdb-frontend on WSL (Windows Subsystem for Linux).","title":"WSL"},{"location":"#issues-about-wsl","text":"On WSL 1, Random port option is not usable on WSL becasue /proc/net/tcp interface is not working on WSL. (WSL 2 does not has this problem.)","title":"Issues about WSL"},{"location":"#versioning","text":"Since v0.2.0-beta, GDBFrontend switched to a new versioning strategy.","title":"Versioning"},{"location":"#reading-versions","text":"In vX.Y.Z-STABILITY : X is major versions, changes long term with major features and enhancements. Y is main versions that include new features and enhancements. Z is bugfix releases of main versions. STABILITY is stability level of the release. ( alpha , beta , rcN , stable )","title":"Reading Versions"},{"location":"#documentation","text":"Documentation is TODO yet.","title":"Documentation"},{"location":"#api-documentation","text":"API Documentation is TODO yet.","title":"API Documentation"},{"location":"#plugin-development","text":"You can read the Plugin Development Tutorial .","title":"Plugin Development"},{"location":"#theme-development","text":"Themes are developed as plugins.","title":"Theme Development"},{"location":"#discord","text":"Join to Discord community.","title":"Discord"},{"location":"#contributing","text":"You can contribute with commiting to project or developing a plugin. All commits are welcome.","title":"\ud83c\udf8a Contributing"},{"location":"#donate","text":"","title":"\u2764\ufe0f Donate"},{"location":"#patreon","text":"","title":"Patreon"},{"location":"#bitcoin","text":"You can donate to support the project. QR Code Bitcoin address for donations 3KBtYfaAT42uVFd6D2XFRDTAoErLz73vpL","title":"Bitcoin"},{"location":"#license","text":"Copyright (C) 2019, O\u011fuzhan Ero\u011flu rohanrhu2@gmail.com (https://oguzhaneroglu.com/) GNU General Public License v3 (GPL-3) You may copy, distribute and modify the software as long as you track changes/dates in source files. Any modifications to or software including (via compiler) GPL-licensed code must also be made available under the GPL along with build & install instructions.","title":"License"},{"location":"tutorials/embedded-debugging/","text":"Embedded Debugging with GDBFrontend Using build_gdb.sh to build latest GDB for ARM target with embedded-Python3 You can use build_gdb.sh to build your own GDB w/ Python3 support for ARM target. The script will also create a special command for using GDBFrontend on your own GDB build. (Like gdbfrontend-gdb-11.2 .) ./build_gdb.sh --target = arm-none-eabi Now you can use gdbfrontend-gdb-{version} command. Just like: gdbfrontend-gdb-11.2 or How to build GDB for ARM with embedded-Python3 GDBFrontend needs GDB-embedded Python3. Sometimes, you could not find a GDB build for ARM target ( arm-none-eabi ) with Python3 support on GDB. In this situation you can quickly build your own GDB with Python3 support and arm-none-eabi target. You may need some build-time dependencies You must install GDB's build dependencies that are listed here: https://sourceware.org/gdb/onlinedocs/gdb/Requirements.html If you have some missing build dependencies, configure script will say the missing library, just find it in your package management system and install. Please edit and update this article if you have an issue about build dependencies and you know how to install them. Follow these steps cd ~ wget https://ftp.gnu.org/gnu/gdb/gdb-11.1.tar.xz tar zxvf gdb-11.1.tar.gz mkdir gdb-11.1-build cd gdb-11.1-build ../gdb-11.1/configure --with-python = /usr/bin/python3 --target = arm-none-eabi --enable-interwork --enable-multilib make As you see, you should pass your Python3 executable to configure script's --with-python paramter just like --with-python=/usr/bin/python3 . Starting GDBFrontend with your GDB build After build is successful, you should be able to run GDBFrontend like this: gdbfrontend -g $( realpath ~/gdb-11.1-build/gdb/gdb ) -G --data-directory = $( realpath ~/gdb-11.1-build/gdb/data-directory/ ) It looks like this:","title":"Embedded Debugging with GDBFrontend"},{"location":"tutorials/embedded-debugging/#embedded-debugging-with-gdbfrontend","text":"","title":"Embedded Debugging with GDBFrontend"},{"location":"tutorials/embedded-debugging/#using-build_gdbsh-to-build-latest-gdb-for-arm-target-with-embedded-python3","text":"You can use build_gdb.sh to build your own GDB w/ Python3 support for ARM target. The script will also create a special command for using GDBFrontend on your own GDB build. (Like gdbfrontend-gdb-11.2 .) ./build_gdb.sh --target = arm-none-eabi Now you can use gdbfrontend-gdb-{version} command. Just like: gdbfrontend-gdb-11.2","title":"Using build_gdb.sh to build latest GDB for ARM target with embedded-Python3"},{"location":"tutorials/embedded-debugging/#or-how-to-build-gdb-for-arm-with-embedded-python3","text":"GDBFrontend needs GDB-embedded Python3. Sometimes, you could not find a GDB build for ARM target ( arm-none-eabi ) with Python3 support on GDB. In this situation you can quickly build your own GDB with Python3 support and arm-none-eabi target.","title":"or How to build GDB for ARM with embedded-Python3"},{"location":"tutorials/embedded-debugging/#you-may-need-some-build-time-dependencies","text":"You must install GDB's build dependencies that are listed here: https://sourceware.org/gdb/onlinedocs/gdb/Requirements.html If you have some missing build dependencies, configure script will say the missing library, just find it in your package management system and install. Please edit and update this article if you have an issue about build dependencies and you know how to install them.","title":"You may need some build-time dependencies"},{"location":"tutorials/embedded-debugging/#follow-these-steps","text":"cd ~ wget https://ftp.gnu.org/gnu/gdb/gdb-11.1.tar.xz tar zxvf gdb-11.1.tar.gz mkdir gdb-11.1-build cd gdb-11.1-build ../gdb-11.1/configure --with-python = /usr/bin/python3 --target = arm-none-eabi --enable-interwork --enable-multilib make As you see, you should pass your Python3 executable to configure script's --with-python paramter just like --with-python=/usr/bin/python3 .","title":"Follow these steps"},{"location":"tutorials/embedded-debugging/#starting-gdbfrontend-with-your-gdb-build","text":"After build is successful, you should be able to run GDBFrontend like this: gdbfrontend -g $( realpath ~/gdb-11.1-build/gdb/gdb ) -G --data-directory = $( realpath ~/gdb-11.1-build/gdb/data-directory/ ) It looks like this:","title":"Starting GDBFrontend with your GDB build"},{"location":"tutorials/makefile-integration/","text":"How to integrate GDBFrontend with your Makefile? GDBFrontend has very powerful APIs on different protocols that allow you to extend and integrate your debugger into very large scale of possibilities. First think you start your debugger: gdbfrontend If you are not specifying a port, the default port is 5550 . You can specify the port with -p PORT parameter. If you want to start multiple GDBFrontend sessions, you should specify different ports and terminal IDs for each debugger. Just like: gdbfrontend # debugger one, default port: 5550 and default terminal ID: gdb-frontend gdbfrontend -p 5551 -t gdb-frontend-2 # second debugger Load the executable to debugger When we load the executable, it will reload it when you re-build it. Just click to Load Executable button on top left side. Let's add a debug recipe to call GDBFrontend HTTP API We are going to use GDBFrontend's HTTP API in our Makefile . We should send a request to this: curl http://127.0.0.1:5550/api/runtime/run Before integration, the Makefile looks like this: CC = gcc CFLAGS = -std = c99 -I../../ -O3 -g JSONIC_SOURCES = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.c\" )) JSONIC_HEADERS = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.h\" )) JSONIC_OBJ = $( JSONIC_SOURCES:.c = .o ) SOURCE = heroes.c EXECUTABLE = $( SOURCE:.c = .exe ) ifeq ($(OS), Windows_NT) RM = rm -rf else RM = rm -rf endif $(EXECUTABLE) : $( JSONIC_OBJ ) $( CC ) -o $@ $( SOURCE ) $< $( CFLAGS ) clean : $( RM ) $( EXECUTABLE ) We are going to add a debug recipe to our Makefile : debug : $( EXECUTABLE ) @curl http://127.0.0.1:5550/api/runtime/run Finally the Makefile will look like this: CC = gcc CFLAGS = -std = c99 -I../../ -O3 -g JSONIC_SOURCES = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.c\" )) JSONIC_HEADERS = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.h\" )) JSONIC_OBJ = $( JSONIC_SOURCES:.c = .o ) SOURCE = heroes.c EXECUTABLE = $( SOURCE:.c = .exe ) ifeq ($(OS), Windows_NT) RM = rm -rf else RM = rm -rf endif $(EXECUTABLE) : $( JSONIC_OBJ ) $( CC ) -o $@ $( SOURCE ) $< $( CFLAGS ) clean : $( RM ) $( EXECUTABLE ) debug : $( EXECUTABLE ) @curl http://127.0.0.1:5550/api/runtime/run Let's use our debug recipe We added a debug recipe into the Makefile . Now we can use it like this: make clean ; make debug This will build your application and start your application on GDBFrontend. Getting a variable for a specific testing For an example to special debugger integration requirements, let's see this example. Don't forget to apply URL encoding: For example sending a parameter: http://127.0.0.1:5550/api/frame/variable?expression=\"jsonic_object_get(json_string, root, \"squadName\")->val\" Should be like this: http://127.0.0.1:5550/api/frame/variable?expression=\"jsonic_object_get(json_string%2C%20root%2C%20%22squadName%22)-%3Eval\" Just add this to the Makefile recipe: debug : $( EXECUTABLE ) @curl http://127.0.0.1:5550/api/runtime/run $( info Waiting debugger to interrupt... ) @sleep 5 $( info Value for expression: \"jsonic_object_get(json_string, root, \" squadName \")->val\" ) @eval echo \" $$ (curl http://127.0.0.1:5550/api/frame/variable?expression=\" jsonic_object_get ( json_string%2C%20root%2C%20%22squadName%22 ) -%3Eval \")\" You will an output like this: root@milkyway:/mnt/c/proje/jsonic/examples/heroes# make debug Waiting debugger to interrupt... Value for expression: \"jsonic_object_get(json_string, root, \" squadName \")->val\" { \"ok\" : true }{ ok: true, variable: { is_global: false, name: val, expression: jsonic_object_get ( json_string, root, \"squadName\" ) ->val, is_pointer: true, is_optimized_out: false, address: 0x55555555ac78, value: Super \"hero\" squad, is_nts: true, type: { alignof: 8 , code: 1 , name: null, sizeof: 8 , tag: null, is_pointer: true, terminal: { alignof: 1 , code: 8 , name: char, sizeof: 1 , tag: null, is_pointer: false }} , type_tree: [{ alignof: 8 , code: 1 , name: null, sizeof: 8 , tag: null, is_pointer: true } , { alignof: 1 , code: 8 , name: char, sizeof: 1 , tag: null, is_pointer: false }] , members: []}} root@milkyway:/mnt/c/proje/jsonic/examples/heroes# You may be noticed that we've added sleep 5 to wait the debugger to start and interrupt application. This is a bad approach of course, you can write your own script and use GDBFrontend's WebSocket API to listen events like stop event and do your jobs on events. What's now? Possibilities are infinite. You can follow Plugin Development Tutorial to make your own complex integrations. By writing your own GDBFrontend plugin, you can make your own Python, HTTP and WebSocket APIs and you can communicate to them from other platforms. Some ideas for integrations For special development and debuggin requirements you can do something like these with your own plugin: Restarting debugging Adding breakpoints Writing your own GDBFrontendd plugin to use it for special debugging requirements and integrations Writing your own WebSocket client to listen debugging events Spawning an evaluater window Make your own custom data visualizer and trigger them from your integrations Using terminal API for special requirements Happy debugging! \u2764\ufe0f","title":"How to integrate GDBFrontend with your Makefile?"},{"location":"tutorials/makefile-integration/#how-to-integrate-gdbfrontend-with-your-makefile","text":"GDBFrontend has very powerful APIs on different protocols that allow you to extend and integrate your debugger into very large scale of possibilities. First think you start your debugger: gdbfrontend If you are not specifying a port, the default port is 5550 . You can specify the port with -p PORT parameter. If you want to start multiple GDBFrontend sessions, you should specify different ports and terminal IDs for each debugger. Just like: gdbfrontend # debugger one, default port: 5550 and default terminal ID: gdb-frontend gdbfrontend -p 5551 -t gdb-frontend-2 # second debugger","title":"How to integrate GDBFrontend with your Makefile?"},{"location":"tutorials/makefile-integration/#load-the-executable-to-debugger","text":"When we load the executable, it will reload it when you re-build it. Just click to Load Executable button on top left side.","title":"Load the executable to debugger"},{"location":"tutorials/makefile-integration/#lets-add-a-debug-recipe-to-call-gdbfrontend-http-api","text":"We are going to use GDBFrontend's HTTP API in our Makefile . We should send a request to this: curl http://127.0.0.1:5550/api/runtime/run Before integration, the Makefile looks like this: CC = gcc CFLAGS = -std = c99 -I../../ -O3 -g JSONIC_SOURCES = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.c\" )) JSONIC_HEADERS = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.h\" )) JSONIC_OBJ = $( JSONIC_SOURCES:.c = .o ) SOURCE = heroes.c EXECUTABLE = $( SOURCE:.c = .exe ) ifeq ($(OS), Windows_NT) RM = rm -rf else RM = rm -rf endif $(EXECUTABLE) : $( JSONIC_OBJ ) $( CC ) -o $@ $( SOURCE ) $< $( CFLAGS ) clean : $( RM ) $( EXECUTABLE ) We are going to add a debug recipe to our Makefile : debug : $( EXECUTABLE ) @curl http://127.0.0.1:5550/api/runtime/run Finally the Makefile will look like this: CC = gcc CFLAGS = -std = c99 -I../../ -O3 -g JSONIC_SOURCES = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.c\" )) JSONIC_HEADERS = $( filter-out $( shell find ../../ -path \"*/examples/*\" ) , $( shell find ../../ -name \"*.h\" )) JSONIC_OBJ = $( JSONIC_SOURCES:.c = .o ) SOURCE = heroes.c EXECUTABLE = $( SOURCE:.c = .exe ) ifeq ($(OS), Windows_NT) RM = rm -rf else RM = rm -rf endif $(EXECUTABLE) : $( JSONIC_OBJ ) $( CC ) -o $@ $( SOURCE ) $< $( CFLAGS ) clean : $( RM ) $( EXECUTABLE ) debug : $( EXECUTABLE ) @curl http://127.0.0.1:5550/api/runtime/run","title":"Let's add a debug recipe to call GDBFrontend HTTP API"},{"location":"tutorials/makefile-integration/#lets-use-our-debug-recipe","text":"We added a debug recipe into the Makefile . Now we can use it like this: make clean ; make debug This will build your application and start your application on GDBFrontend.","title":"Let's use our debug recipe"},{"location":"tutorials/makefile-integration/#getting-a-variable-for-a-specific-testing","text":"For an example to special debugger integration requirements, let's see this example. Don't forget to apply URL encoding: For example sending a parameter: http://127.0.0.1:5550/api/frame/variable?expression=\"jsonic_object_get(json_string, root, \"squadName\")->val\" Should be like this: http://127.0.0.1:5550/api/frame/variable?expression=\"jsonic_object_get(json_string%2C%20root%2C%20%22squadName%22)-%3Eval\" Just add this to the Makefile recipe: debug : $( EXECUTABLE ) @curl http://127.0.0.1:5550/api/runtime/run $( info Waiting debugger to interrupt... ) @sleep 5 $( info Value for expression: \"jsonic_object_get(json_string, root, \" squadName \")->val\" ) @eval echo \" $$ (curl http://127.0.0.1:5550/api/frame/variable?expression=\" jsonic_object_get ( json_string%2C%20root%2C%20%22squadName%22 ) -%3Eval \")\" You will an output like this: root@milkyway:/mnt/c/proje/jsonic/examples/heroes# make debug Waiting debugger to interrupt... Value for expression: \"jsonic_object_get(json_string, root, \" squadName \")->val\" { \"ok\" : true }{ ok: true, variable: { is_global: false, name: val, expression: jsonic_object_get ( json_string, root, \"squadName\" ) ->val, is_pointer: true, is_optimized_out: false, address: 0x55555555ac78, value: Super \"hero\" squad, is_nts: true, type: { alignof: 8 , code: 1 , name: null, sizeof: 8 , tag: null, is_pointer: true, terminal: { alignof: 1 , code: 8 , name: char, sizeof: 1 , tag: null, is_pointer: false }} , type_tree: [{ alignof: 8 , code: 1 , name: null, sizeof: 8 , tag: null, is_pointer: true } , { alignof: 1 , code: 8 , name: char, sizeof: 1 , tag: null, is_pointer: false }] , members: []}} root@milkyway:/mnt/c/proje/jsonic/examples/heroes# You may be noticed that we've added sleep 5 to wait the debugger to start and interrupt application. This is a bad approach of course, you can write your own script and use GDBFrontend's WebSocket API to listen events like stop event and do your jobs on events.","title":"Getting a variable for a specific testing"},{"location":"tutorials/makefile-integration/#whats-now","text":"Possibilities are infinite. You can follow Plugin Development Tutorial to make your own complex integrations. By writing your own GDBFrontend plugin, you can make your own Python, HTTP and WebSocket APIs and you can communicate to them from other platforms.","title":"What's now?"},{"location":"tutorials/makefile-integration/#some-ideas-for-integrations","text":"For special development and debuggin requirements you can do something like these with your own plugin: Restarting debugging Adding breakpoints Writing your own GDBFrontendd plugin to use it for special debugging requirements and integrations Writing your own WebSocket client to listen debugging events Spawning an evaluater window Make your own custom data visualizer and trigger them from your integrations Using terminal API for special requirements Happy debugging! \u2764\ufe0f","title":"Some ideas for integrations"},{"location":"tutorials/plugin-development/","text":"How to develop GDBFrontend plugins GDBFrontend supports plugins. Plugin development includes a few simple steps. You can develop plugins easily with following the instructions. Example Plugin There is an example plugin ( hello ) in plugins/hello . Enable it before start the tutorial: Go to config.py and comment the line \"hello\" : disabled_plugins = [ \"hello\" ] Plugin FS Structure GDBFrontend plugins are stored in plugins/ directory in the GDBFrontend root. A typical plugin files look like this: plugins/ hello/ frontend/ html/ hello.html js/ hello.js css/ hello.css url_modules/ api.py config.py urls.py hello.py Plugins those are inside plugins directory will be loaded automatically. Plugin Name Format On File System: hello ( hello/ directory, hello.py ) Plugin Backend Class: HelloPlugin Enabling/Disabling a Plugin You can disable a plugin with adding plugin name to config.disabled_plugins . Plugin Load Order You can specify plugin load order with config.plugin_order . Plugins from config.plugin_order will be loaded in order, after that the rest will be loaded. Plugin Files config.py Includes basic information about your plugin. DESCRIPTION = \"Example GDBFrontend plugin.\" AUTHOR = \"O\u011fuzhan Ero\u011flu <rohanrhu2@gmail.com> (https://oguzhaneroglu.com/)\" HOMEPAGE = \"https://github.com/rohanrhu/gdb-frontend\" VERSION = [ 0 , 0 , 1 ] hello.py Plugin backend file must be named as [plugin name].py and plugin class must be named as [plugin name]Plugin and intherits plugin.GDBFrontendPlugin . import importlib import plugin gdb = importlib . import_module ( \"gdb\" ) class HelloPlugin ( plugin . GDBFrontendPlugin ): def __init__ ( self ): plugin . GDBFrontendPlugin . __init__ ( self ) def loaded ( self ): gdb . events . new_objfile . connect ( self . gdb_on_new_objfile ) def unloaded ( self ): gdb . events . new_objfile . disconnect ( self . gdb_on_new_objfile ) def gdb_on_new_objfile ( self , event ): print ( \"[HELLO] Event: new_objfile:\" , event ) urls.py Includes URL definitions for GDBFrontend REST API. Plugins can define URLs and use them for communicating with each other. URLs must be defined in a python dict named as urls in the following format: urls = { \"example-api\" : { \"url\" : \"/hello/api\" , \"match\" : \"^/hello/api\" , \"module\" : \"plugins.hello.url_modules.api\" } } Rest API Modules Rest API Module URLs must be defined in plugin.urls . Module files are stored in url_modules/ directory. Plugin URL modules can be accessed with the path like plugins.hello.url_modules.[module name] and you must use it for plugin.urls[\"[plugin name]\"][\"module\"] . A URL module file includes a function named as run(request, params) and GDBFrontend calls that on HTTP request. A typical URL module like this: import json import urllib import api.debug def run ( request , params ): if params is None : params = {} url_path = urllib . parse . urlparse ( request . path ) qs_params = urllib . parse . parse_qs ( url_path . query ) result_json = {} result_json [ \"ok\" ] = True result_json [ \"sources\" ] = api . debug . getSources () request . send_response ( 200 ) request . send_header ( \"Content-Type\" , \"application/json; charset=utf-8\" ) request . end_headers () request . wfile . write ( json . dumps ( result_json ) . encode ()) Plugin Objects Plugin objects are exists in plugin.plugins dict as plugin.plugins[\"[plugin name]\"] = plugin and plugin is an instance of your plugin class that inherits GDBFrontendPlugin . Plugin Object Attributes plugin.module plugin.name plugin.is_loaded plugin.location plugin.config plugin.urls Frontend Frontend files are stored in the plugins/[plugin name]/frontend/ directory. There are three basic directory: frontend/ css/ [plugin name].css html/ [plugin name].html js/ [plugin name].js Those three files will be included as default: * html/[plugin_name].html will be included to DOM as default. * css/[plugin_name].css will be included as default. * js/[plugin_name].js will be included as default. Plugin's frontend/ directory is also served over HTTP and its content will be accessable with a URL like /plugins/[plugin_name]/html/foo.html or /plugins/[plugin_name]/js/bar.js . GDBFrontend Namespace All GDBFrontend stuff are exists in GDBFrontend object in Javascript. An example, you can access version like GDBFrontend.version . Backend Configuration You can access backend configuration via GDBFrontend.config . Frontend Components Root Components All root components are stored in GDBFrontend.components . Sub Components Sub components are stored in component.components . Component: gdbFrontend GDBFrontend is the main component at root and it uses another components as sub component. It is accesable with GDBFrontend.components.gdbFrontend . Sub components of gdbFrontend are accessable via GDBFrontend.components.gdbFrontend.components . For an example you can get open file tabs like this: > GDBFrontend . components . gdbFrontend . components . fileTabs . files < ( 3 ) [{ \u2026 }, { \u2026 }, { \u2026 }] or getting breakpoints from BreakpointsEditor component instance from GDBFrontend component instance. > GDBFrontend . components . gdbFrontend . components . breakpointsEditor . breakpoints < [{ \u2026 }, { \u2026 }] Let's switch to first file tab: var switchTo = GDBFrontend . components . gdbFrontend . components . fileTabs . files [ 0 ]; GDBFrontend . components . gdbFrontend . components . fileTabs . switchFile ({ file : switchTo });","title":"How to develop GDBFrontend plugins"},{"location":"tutorials/plugin-development/#how-to-develop-gdbfrontend-plugins","text":"GDBFrontend supports plugins. Plugin development includes a few simple steps. You can develop plugins easily with following the instructions.","title":"How to develop GDBFrontend plugins"},{"location":"tutorials/plugin-development/#example-plugin","text":"There is an example plugin ( hello ) in plugins/hello . Enable it before start the tutorial: Go to config.py and comment the line \"hello\" : disabled_plugins = [ \"hello\" ]","title":"Example Plugin"},{"location":"tutorials/plugin-development/#plugin-fs-structure","text":"GDBFrontend plugins are stored in plugins/ directory in the GDBFrontend root. A typical plugin files look like this: plugins/ hello/ frontend/ html/ hello.html js/ hello.js css/ hello.css url_modules/ api.py config.py urls.py hello.py Plugins those are inside plugins directory will be loaded automatically.","title":"Plugin FS Structure"},{"location":"tutorials/plugin-development/#plugin-name-format","text":"On File System: hello ( hello/ directory, hello.py ) Plugin Backend Class: HelloPlugin","title":"Plugin Name Format"},{"location":"tutorials/plugin-development/#enablingdisabling-a-plugin","text":"You can disable a plugin with adding plugin name to config.disabled_plugins .","title":"Enabling/Disabling a Plugin"},{"location":"tutorials/plugin-development/#plugin-load-order","text":"You can specify plugin load order with config.plugin_order . Plugins from config.plugin_order will be loaded in order, after that the rest will be loaded.","title":"Plugin Load Order"},{"location":"tutorials/plugin-development/#plugin-files","text":"","title":"Plugin Files"},{"location":"tutorials/plugin-development/#configpy","text":"Includes basic information about your plugin. DESCRIPTION = \"Example GDBFrontend plugin.\" AUTHOR = \"O\u011fuzhan Ero\u011flu <rohanrhu2@gmail.com> (https://oguzhaneroglu.com/)\" HOMEPAGE = \"https://github.com/rohanrhu/gdb-frontend\" VERSION = [ 0 , 0 , 1 ]","title":"config.py"},{"location":"tutorials/plugin-development/#hellopy","text":"Plugin backend file must be named as [plugin name].py and plugin class must be named as [plugin name]Plugin and intherits plugin.GDBFrontendPlugin . import importlib import plugin gdb = importlib . import_module ( \"gdb\" ) class HelloPlugin ( plugin . GDBFrontendPlugin ): def __init__ ( self ): plugin . GDBFrontendPlugin . __init__ ( self ) def loaded ( self ): gdb . events . new_objfile . connect ( self . gdb_on_new_objfile ) def unloaded ( self ): gdb . events . new_objfile . disconnect ( self . gdb_on_new_objfile ) def gdb_on_new_objfile ( self , event ): print ( \"[HELLO] Event: new_objfile:\" , event )","title":"hello.py"},{"location":"tutorials/plugin-development/#urlspy","text":"Includes URL definitions for GDBFrontend REST API. Plugins can define URLs and use them for communicating with each other. URLs must be defined in a python dict named as urls in the following format: urls = { \"example-api\" : { \"url\" : \"/hello/api\" , \"match\" : \"^/hello/api\" , \"module\" : \"plugins.hello.url_modules.api\" } }","title":"urls.py"},{"location":"tutorials/plugin-development/#rest-api-modules","text":"Rest API Module URLs must be defined in plugin.urls . Module files are stored in url_modules/ directory. Plugin URL modules can be accessed with the path like plugins.hello.url_modules.[module name] and you must use it for plugin.urls[\"[plugin name]\"][\"module\"] . A URL module file includes a function named as run(request, params) and GDBFrontend calls that on HTTP request. A typical URL module like this: import json import urllib import api.debug def run ( request , params ): if params is None : params = {} url_path = urllib . parse . urlparse ( request . path ) qs_params = urllib . parse . parse_qs ( url_path . query ) result_json = {} result_json [ \"ok\" ] = True result_json [ \"sources\" ] = api . debug . getSources () request . send_response ( 200 ) request . send_header ( \"Content-Type\" , \"application/json; charset=utf-8\" ) request . end_headers () request . wfile . write ( json . dumps ( result_json ) . encode ())","title":"Rest API Modules"},{"location":"tutorials/plugin-development/#plugin-objects","text":"Plugin objects are exists in plugin.plugins dict as plugin.plugins[\"[plugin name]\"] = plugin and plugin is an instance of your plugin class that inherits GDBFrontendPlugin .","title":"Plugin Objects"},{"location":"tutorials/plugin-development/#plugin-object-attributes","text":"plugin.module plugin.name plugin.is_loaded plugin.location plugin.config plugin.urls","title":"Plugin Object Attributes"},{"location":"tutorials/plugin-development/#frontend","text":"Frontend files are stored in the plugins/[plugin name]/frontend/ directory. There are three basic directory: frontend/ css/ [plugin name].css html/ [plugin name].html js/ [plugin name].js Those three files will be included as default: * html/[plugin_name].html will be included to DOM as default. * css/[plugin_name].css will be included as default. * js/[plugin_name].js will be included as default. Plugin's frontend/ directory is also served over HTTP and its content will be accessable with a URL like /plugins/[plugin_name]/html/foo.html or /plugins/[plugin_name]/js/bar.js .","title":"Frontend"},{"location":"tutorials/plugin-development/#gdbfrontend-namespace","text":"All GDBFrontend stuff are exists in GDBFrontend object in Javascript. An example, you can access version like GDBFrontend.version .","title":"GDBFrontend Namespace"},{"location":"tutorials/plugin-development/#backend-configuration","text":"You can access backend configuration via GDBFrontend.config .","title":"Backend Configuration"},{"location":"tutorials/plugin-development/#frontend-components","text":"","title":"Frontend Components"},{"location":"tutorials/plugin-development/#root-components","text":"All root components are stored in GDBFrontend.components .","title":"Root Components"},{"location":"tutorials/plugin-development/#sub-components","text":"Sub components are stored in component.components .","title":"Sub Components"},{"location":"tutorials/plugin-development/#component-gdbfrontend","text":"GDBFrontend is the main component at root and it uses another components as sub component. It is accesable with GDBFrontend.components.gdbFrontend . Sub components of gdbFrontend are accessable via GDBFrontend.components.gdbFrontend.components . For an example you can get open file tabs like this: > GDBFrontend . components . gdbFrontend . components . fileTabs . files < ( 3 ) [{ \u2026 }, { \u2026 }, { \u2026 }] or getting breakpoints from BreakpointsEditor component instance from GDBFrontend component instance. > GDBFrontend . components . gdbFrontend . components . breakpointsEditor . breakpoints < [{ \u2026 }, { \u2026 }] Let's switch to first file tab: var switchTo = GDBFrontend . components . gdbFrontend . components . fileTabs . files [ 0 ]; GDBFrontend . components . gdbFrontend . components . fileTabs . switchFile ({ file : switchTo });","title":"Component: gdbFrontend"},{"location":"tutorials/python-c-extension-debugging/","text":"How to debug a Python C extension with GDBFrontend Hi, in this tutorial, I'm going to show you how to debug a native C Python extension. Installing Python3 debug symbols To debug Python3, you need debug symbols for it. On Debian: sudo apt install python3-dbg I have no idea about other distros. Just search about \"Python debug symbols on DISTRO\" Build your extension with debug symbols Just set CFLAGS environment variables: CFLAGS = \"-O0 -g\" python3 setup.py build Let's debug! First thing, we are going to start GDBFrontend: gdbfrontend GDBFrontend will open a browser tab as a default behavior but if it doesn't happen, you can open the app URL: http://127.0.0.1:5550/terminal/ Optionally you can run it as a Chrome/Chromium app: chrome --app = http://127.0.0.1:5550/terminal/ Optionally choose the Doki Theme xD We just need to add split the terminal and start a Python3 interpeter on the right side. To attach GDB to our Python3 process, we need PID of our Python PID. >>> import os >>> os . getpid () 25524 And on GDB shell: (gdb) attach 25524 At this point, GDB will immediately stop the process. Just click to continue button (the second button on top) or press F6 . Import your module on Python prompt and unfocus from terminal , now just press Ctrl + P shortcut and type a source name from your Python extension. Congratulations! Now you can add a breakpoint to a function from your extension and use that function!","title":"How to debug a Python C extension with GDBFrontend"},{"location":"tutorials/python-c-extension-debugging/#how-to-debug-a-python-c-extension-with-gdbfrontend","text":"Hi, in this tutorial, I'm going to show you how to debug a native C Python extension.","title":"How to debug a Python C extension with GDBFrontend"},{"location":"tutorials/python-c-extension-debugging/#installing-python3-debug-symbols","text":"To debug Python3, you need debug symbols for it. On Debian: sudo apt install python3-dbg I have no idea about other distros. Just search about \"Python debug symbols on DISTRO\"","title":"Installing Python3 debug symbols"},{"location":"tutorials/python-c-extension-debugging/#build-your-extension-with-debug-symbols","text":"Just set CFLAGS environment variables: CFLAGS = \"-O0 -g\" python3 setup.py build","title":"Build your extension with debug symbols"},{"location":"tutorials/python-c-extension-debugging/#lets-debug","text":"First thing, we are going to start GDBFrontend: gdbfrontend GDBFrontend will open a browser tab as a default behavior but if it doesn't happen, you can open the app URL: http://127.0.0.1:5550/terminal/ Optionally you can run it as a Chrome/Chromium app: chrome --app = http://127.0.0.1:5550/terminal/ Optionally choose the Doki Theme xD We just need to add split the terminal and start a Python3 interpeter on the right side. To attach GDB to our Python3 process, we need PID of our Python PID. >>> import os >>> os . getpid () 25524 And on GDB shell: (gdb) attach 25524 At this point, GDB will immediately stop the process. Just click to continue button (the second button on top) or press F6 . Import your module on Python prompt and unfocus from terminal , now just press Ctrl + P shortcut and type a source name from your Python extension. Congratulations! Now you can add a breakpoint to a function from your extension and use that function!","title":"Let's debug!"}]}